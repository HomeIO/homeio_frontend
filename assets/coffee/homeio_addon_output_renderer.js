// Generated by CoffeeScript 1.10.0
(function() {
  this.HomeIOAddonOutputRenderer = (function() {
    function HomeIOAddonOutputRenderer() {
      this.name = null;
      this.keyName = null;
      this.container = null;
      this.addonObject = null;
      this.useGraph = false;
    }

    HomeIOAddonOutputRenderer.prototype.start = function() {
      return this.getFromApi();
    };

    HomeIOAddonOutputRenderer.prototype.getFromApi = function() {
      return $.getJSON("/api/addons/" + this.name + "/.json", (function(_this) {
        return function(data) {
          _this.addonObject = data.object;
          return _this.render();
        };
      })(this));
    };

    HomeIOAddonOutputRenderer.prototype.render = function() {
      if (this.useGraph === false) {
        if (this.addonObject["array"]) {
          return this.renderArray(this.addonObject["array"], this.addonObject["keys"]);
        }
      } else {
        if (this.addonObject["array"]) {
          return this.renderGraph(this.addonObject["array"], this.addonObject["keys"]);
        }
      }
    };

    HomeIOAddonOutputRenderer.prototype.renderArray = function(array, keys) {
      var cellHtml, headHtml, headerLink, i, j, k, key, keyDef, keyLink, len, len1, len2, row, rowHtml, tableHtml;
      tableHtml = $('<table></table>').addClass('pure-table pure-table-striped addonDynamicTable');
      headHtml = $('<thead></thead');
      tableHtml.append(headHtml);
      rowHtml = $('<tr></tr>');
      headHtml.append(rowHtml);
      for (i = 0, len = keys.length; i < len; i++) {
        keyDef = keys[i];
        key = keyDef.key;
        keyLink = key;
        if (key === "time") {
          keyLink = "all";
        }
        headerLink = $('<a></a>').attr("href", "/#/addons/" + this.name + "/graph/" + keyLink);
        headerLink.text(key);
        cellHtml = $('<th></th>');
        cellHtml.append(headerLink);
        rowHtml.append(cellHtml);
      }
      for (j = 0, len1 = array.length; j < len1; j++) {
        row = array[j];
        rowHtml = $('<tr></tr>');
        tableHtml.append(rowHtml);
        for (k = 0, len2 = keys.length; k < len2; k++) {
          keyDef = keys[k];
          cellHtml = $('<td></td>').prop('title', row[keyDef.key]);
          cellHtml.text(this.processValue(row, keyDef));
          rowHtml.append(cellHtml);
        }
      }
      return $(this.container).append(tableHtml);
    };

    HomeIOAddonOutputRenderer.prototype.renderGraph = function(array, keys) {
      var avg_data, graphElement, h, i, j, len, len1, max_data, min_data, new_data, row;
      graphElement = $(this.container);
      h = $('body').height() - 40;
      if (h < 200) {
        h = 200;
      }
      graphElement.height(h);
      this.flotOptions = {
        series: {
          lines: {
            show: true,
            fill: true
          },
          points: {
            show: false
          }
        },
        legend: {
          show: true
        },
        grid: {
          clickable: false,
          hoverable: true
        },
        xaxis: {
          mode: "time",
          timezone: "browser"
        }
      };
      if (this.keyName === "all") {
        min_data = [];
        avg_data = [];
        max_data = [];
        for (i = 0, len = array.length; i < len; i++) {
          row = array[i];
          if (row.time) {
            min_data.push([new Date(row.time), row.min]);
            avg_data.push([new Date(row.time), row.avg]);
            max_data.push([new Date(row.time), row.max]);
          }
        }
        new_data = [
          {
            data: max_data,
            label: "max"
          }, {
            data: avg_data,
            label: "avg"
          }, {
            data: min_data,
            label: "min"
          }
        ];
        console.log(new_data);
        return this.plot = $.plot(graphElement, new_data, this.flot_options);
      } else {
        new_data = [];
        for (j = 0, len1 = array.length; j < len1; j++) {
          row = array[j];
          if (row.time) {
            new_data.push([new Date(row.time), row[this.keyName]]);
          } else {
            new_data.push([row[this.keyName]]);
          }
        }
        return this.plot = $.plot(graphElement, [new_data], this.flot_options);
      }
    };

    HomeIOAddonOutputRenderer.prototype.timeToString = function(t) {
      var date;
      date = new Date(parseInt(t));
      return dateFormat(date, "yyyy-mm-dd H:MM:ss");
    };

    HomeIOAddonOutputRenderer.prototype.intervalToString = function(timeInterval) {
      if (timeInterval < 1000) {
        return timeInterval + " ms";
      } else {
        timeInterval = Math.round(timeInterval / 1000.0);
      }
      if (timeInterval < 600) {
        return timeInterval + " s";
      } else {
        timeInterval = Math.round(timeInterval / 60.0);
      }
      if (timeInterval < 600) {
        return timeInterval + " min";
      } else {
        timeInterval = Math.round(timeInterval / 60.0);
      }
      if (timeInterval < (24 * 7)) {
        return timeInterval + " h";
      } else {
        timeInterval = Math.round(timeInterval / 24.0);
      }
      return timeInterval + " days";
    };

    HomeIOAddonOutputRenderer.prototype.processValue = function(row, keyDef) {
      var value;
      value = row[keyDef.key];
      if (keyDef.type === "time") {
        value = this.timeToString(value);
      }
      if (keyDef.coeff) {
        value *= keyDef.coeff;
      }
      if (keyDef.type === "float") {
        value = Number(parseFloat(value)).toFixed(2);
      }
      if (keyDef.unit) {
        value = value + " " + keyDef.unit;
      }
      if (keyDef.type === "interval") {
        if (value === 0) {
          value = "0 s";
        } else {
          value = this.intervalToString(value);
        }
      }
      return value;
    };

    return HomeIOAddonOutputRenderer;

  })();

}).call(this);
