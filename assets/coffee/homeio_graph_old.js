// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.HomeIOMeasGraphBad = (function() {

    function HomeIOMeasGraphBad() {
      this.getRawInterval = __bind(this.getRawInterval, this);

      this.getRaw = __bind(this.getRaw, this);

      this.drawGraph = __bind(this.drawGraph, this);

      this.addToBuffer = __bind(this.addToBuffer, this);
      this.buffer = [];
      this.initial_time = (new Date()).getTime();
      this.last_time = this.initial_time;
      this.periodic = true;
      this.periodic_interval = 3000;
      this.periodic_get_all = true;
      this.buffer_max_size = 200;
      this.flot_options = {
        series: {
          lines: {
            show: true,
            fill: true
          },
          points: {
            show: false
          }
        },
        legend: {
          show: true
        },
        grid: {
          clickable: false,
          hoverable: true
        }
      };
    }

    HomeIOMeasGraphBad.prototype.name = function(meas_name) {
      this.meas = {
        "name": meas_name,
        "interval": 1
      };
      return this.meas_interval = this.meas.interval;
    };

    HomeIOMeasGraphBad.prototype.addToBuffer = function(array) {
      var r, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        r = array[_i];
        if (this.buffer.length >= this.buffer_max_size) {
          this.buffer.shift();
        }
        _results.push(this.buffer.push(r));
      }
      return _results;
    };

    HomeIOMeasGraphBad.prototype.drawGraph = function() {
      var coefficient_linear, coefficient_offset, current_time, d, i, interval, max_page, new_d, new_data, page, time_offset, time_offset_last, unit, x, y, _i, _len, _ref;
      page = 0;
      coefficient_linear = this.meas["coefficientLinear"];
      coefficient_offset = this.meas["coefficientOffset"];
      interval = this.meas_interval;
      current_time = (new Date).getTime();
      time_offset = this.last_time - current_time - page * interval * this.buffer.length;
      time_offset_last = current_time - this.last_time;
      max_page = 1;
      unit = "unit";
      new_data = [];
      i = 0;
      _ref = this.buffer;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        x = -1 * i * interval + time_offset;
        y = (parseFloat(d) + coefficient_offset) * coefficient_linear;
        new_d = [x, y];
        new_data.push(new_d);
        i += 1;
      }
      new_data = {
        data: new_data,
        color: "#55f",
        label: this.meas.name
      };
      if (this.plot) {
        this.plot.setData(new_data);
        return this.plot.draw();
      } else {
        return this.plot = $.plot($(this.element), new_data, this.flot_options);
      }
    };

    HomeIOMeasGraphBad.prototype.getRaw = function() {
      var from, to,
        _this = this;
      from = this.last_time;
      to = (new Date()).getTime();
      return $.getJSON("/api/meas/" + this.meas.name + "/raw_for_time/" + from + "/" + to + "/.json", function(data) {
        _this.meas_interval = data.interval;
        _this.last_time = to;
        _this.addToBuffer(data.data);
        return _this.drawGraph();
      });
    };

    HomeIOMeasGraphBad.prototype.getRawInterval = function() {
      if (this.periodic) {
        return this.getRaw();
      }
    };

    HomeIOMeasGraphBad.prototype.start = function() {
      var _this = this;
      return $.getJSON("/api/meas/" + this.meas.name + "/.json", function(data) {
        _this.meas = data.object;
        _this.coefficient_linear = _this.meas["coefficientLinear"];
        _this.coefficient_offset = _this.meas["coefficientOffset"];
        _this.getRaw();
        return setInterval(_this.getRawInterval, _this.periodic_interval);
      });
    };

    return HomeIOMeasGraphBad;

  })();

  this.HomeIOMeasGraphOld = (function() {

    function HomeIOMeasGraphOld() {}

    HomeIOMeasGraphOld.prototype.meas_graph = function(meas_data, graph_data, element) {
      var buffer, center_unix_rel_time, chart_length, coefficient_linear, coefficient_offset, current_time, d, factor, flot_options, i, interval, last_time, latest_unix_rel_time, max_page, new_d, new_data, offset_unix_rel_time, oldest_unix_rel_time, page, smooth_data, time_offset, time_offset_last, time_range, unit, x, y, _i, _len;
      flot_options = {
        series: {
          lines: {
            show: true,
            fill: true
          },
          points: {
            show: false
          }
        },
        legend: {
          show: true
        },
        grid: {
          clickable: false,
          hoverable: true
        }
      };
      page = 0;
      buffer = graph_data["data"];
      coefficient_linear = meas_data["object"]["coefficientLinear"];
      coefficient_offset = meas_data["object"]["coefficientOffset"];
      interval = graph_data["interval"];
      last_time = graph_data["lastTime"];
      current_time = (new Date).getTime();
      time_offset = last_time - current_time - page * interval * buffer.length;
      time_offset_last = current_time - last_time;
      chart_length = $(element).width();
      max_page = 1;
      unit = "unit";
      new_data = [];
      i = 0;
      for (_i = 0, _len = buffer.length; _i < _len; _i++) {
        d = buffer[_i];
        x = -1 * i * interval + time_offset;
        y = (parseFloat(d) + coefficient_offset) * coefficient_linear;
        console.log(d, coefficient_offset, coefficient_linear);
        new_d = [x, y];
        new_data.push(new_d);
        i += 1;
      }
      if (new_data.length > chart_length) {
        factor = Math.ceil(parseFloat(new_data.length) / parseFloat(chart_length));
        smooth_data = averageData(new_data, factor + smooth);
        new_data = smooth_data;
      }
      if (buffer.length > 0) {
        time_range = new_data[0][0] - new_data[new_data.length - 1][0];
      }
      latest_unix_rel_time = new_data[0][0];
      oldest_unix_rel_time = new_data[new_data.length - 1][0];
      center_unix_rel_time = (latest_unix_rel_time + oldest_unix_rel_time) / 2.0;
      offset_unix_rel_time = latest_unix_rel_time - center_unix_rel_time;
      new_data = {
        data: new_data,
        color: "#55f",
        label: name
      };
      console.log(new_data);
      return $.plot($(element), [new_data], flot_options);
    };

    return HomeIOMeasGraphOld;

  })();

}).call(this);
